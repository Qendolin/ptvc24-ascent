#version 450

// Copy of https://github.com/bevyengine/bevy/blob/2aed777435d26c357ed71cdb8c7b858de35e582e/crates/bevy_pbr/src/ssao/preprocess_depth.wgsl

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D in_depth;
layout(binding = 0, r16f) uniform writeonly restrict image2D out_depth_mip0;
layout(binding = 1, r16f) uniform writeonly restrict image2D out_depth_mip1;
layout(binding = 2, r16f) uniform writeonly restrict image2D out_depth_mip2;
layout(binding = 3, r16f) uniform writeonly restrict image2D out_depth_mip3;
layout(binding = 4, r16f) uniform writeonly restrict image2D out_depth_mip4;


// Used to share the depths from the previous MIP level between all invocations in a workgroup
shared float previous_mip_depth[8][8];

float saturate(float x) {
    return clamp(x, 0.0, 1.0);
}

// Using 4 depths from the previous MIP, compute a weighted average for the depth of the current MIP
float weighted_average(float depth0, float depth1, float depth2, float depth3) {
    const float depth_range_scale_factor = 0.75;
    const float effect_radius = depth_range_scale_factor * 0.5 * 1.457;
    const float falloff_range = 0.615 * effect_radius;
    const float falloff_from = effect_radius * (1.0 - 0.615);
    const float falloff_mul = -1.0 / falloff_range;
    const float falloff_add = falloff_from / falloff_range + 1.0;

    float min_depth = min(min(depth0, depth1), min(depth2, depth3));
    float weight0 = saturate((depth0 - min_depth) * falloff_mul + falloff_add);
    float weight1 = saturate((depth1 - min_depth) * falloff_mul + falloff_add);
    float weight2 = saturate((depth2 - min_depth) * falloff_mul + falloff_add);
    float weight3 = saturate((depth3 - min_depth) * falloff_mul + falloff_add);
    float weight_total = weight0 + weight1 + weight2 + weight3;

    return ((weight0 * depth0) + (weight1 * depth1) + (weight2 * depth2) + (weight3 * depth3)) / weight_total;
}

void main() {
	ivec2 local_coord = ivec2(gl_LocalInvocationID.xy);
	ivec2 global_coord = ivec2(gl_GlobalInvocationID.xy);

	// MIP 0 - Copy 4 texels from the input depth (per invocation, 8x8 invocations per workgroup)
    ivec2 tex_coords0 = global_coord.xy * 2;
    ivec2 tex_coords1 = tex_coords0 + ivec2(1, 0);
    ivec2 tex_coords2 = tex_coords0 + ivec2(0, 1);
    ivec2 tex_coords3 = tex_coords0 + ivec2(1, 1);

    vec2 depths_uv = (tex_coords0 + vec2(0.5)) / textureSize(in_depth, 0).xy;
    vec4 depths = textureGather(in_depth, depths_uv, 0); // gather 4 depth samples

    imageStore(out_depth_mip0, tex_coords0, vec4(depths.w));
    imageStore(out_depth_mip0, tex_coords1, vec4(depths.z));
    imageStore(out_depth_mip0, tex_coords2, vec4(depths.x));
    imageStore(out_depth_mip0, tex_coords3, vec4(depths.y));

	// MIP 1 - Weighted average of MIP 0's depth values (per invocation, 8x8 invocations per workgroup)
    float depth_mip1 = weighted_average(depths.w, depths.z, depths.x, depths.y);
    imageStore(out_depth_mip1, global_coord, vec4(depth_mip1));
    previous_mip_depth[local_coord.x][local_coord.y] = depth_mip1;

	memoryBarrierShared();
    barrier();

	// MIP 2 - Weighted average of MIP 1's depth values (per invocation, 4x4 invocations per workgroup)
    if (all(equal(local_coord.xy % uvec2(2), uvec2(0)))) {
        float depth0 = previous_mip_depth[local_coord.x + 0][local_coord.y + 0];
        float depth1 = previous_mip_depth[local_coord.x + 1][local_coord.y + 0];
        float depth2 = previous_mip_depth[local_coord.x + 0][local_coord.y + 1];
        float depth3 = previous_mip_depth[local_coord.x + 1][local_coord.y + 1];
        float depth_mip2 = weighted_average(depth0, depth1, depth2, depth3);
        imageStore(out_depth_mip2, global_coord / 2, vec4(depth_mip2));
        previous_mip_depth[local_coord.x][local_coord.y] = depth_mip2;
    }

	memoryBarrierShared();
    barrier();

	// MIP 3 - Weighted average of MIP 2's depth values (per invocation, 2x2 invocations per workgroup)
    if (all(equal(local_coord.xy % uvec2(4), uvec2(0)))) {
        float depth0 = previous_mip_depth[local_coord.x + 0][local_coord.y + 0];
        float depth1 = previous_mip_depth[local_coord.x + 2][local_coord.y + 0];
        float depth2 = previous_mip_depth[local_coord.x + 0][local_coord.y + 2];
        float depth3 = previous_mip_depth[local_coord.x + 2][local_coord.y + 2];
        float depth_mip3 = weighted_average(depth0, depth1, depth2, depth3);
        imageStore(out_depth_mip3, global_coord / 4, vec4(depth_mip3));
        previous_mip_depth[local_coord.x][local_coord.y] = depth_mip3;
    }

	memoryBarrierShared();
    barrier();

	// MIP 4 - Weighted average of MIP 3's depth values (per invocation, 1 invocation per workgroup)
    if (all(equal(local_coord.xy % uvec2(8), uvec2(0)))) {
        float depth0 = previous_mip_depth[local_coord.x + 0][local_coord.y + 0];
        float depth1 = previous_mip_depth[local_coord.x + 4][local_coord.y + 0];
        float depth2 = previous_mip_depth[local_coord.x + 0][local_coord.y + 4];
        float depth3 = previous_mip_depth[local_coord.x + 4][local_coord.y + 4];
        float depth_mip4 = weighted_average(depth0, depth1, depth2, depth3);
        imageStore(out_depth_mip4, global_coord / 8, vec4(depth_mip4));
    }
}