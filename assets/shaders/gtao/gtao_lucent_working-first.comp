#version 450

// Copy of https://github.com/bferan/lucent/blob/main/src/shaders/GTAO.shader

// Ground Truth-based Ambient Occlusion (GTAO)
// Paper: https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf
// Presentation: https://blog.selfshadow.com/publications/s2016-shading-course/activision/s2016_pbs_activision_occlusion.pdf

// Source code heavily based on XeGTAO v1.30 from Intel
// https://github.com/GameTechDev/XeGTAO/blob/0d177ce06bfa642f64d8af4de1197ad1bcb862d4/Source/Rendering/Shaders/XeGTAO.hlsli

// Further References:
// https://github.com/AmplifyCreations/AmplifyOcclusion/blob/809c2782bd54abb743d55c89488fed8a72fe8905/Assets/AmplifyOcclusion/Resources/GTAO.cginc

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const float PI = 3.14159265359;
const float HALF_PI = PI / 2.0;

layout(binding = 0) uniform sampler2D in_depth_mips;
layout(binding = 1) uniform sampler2D in_view_normals;
layout(binding = 2) uniform usampler2D hilbert_index_lut;
// layout(binding = 0, r16f) uniform writeonly restrict image2D ambient_occlusion;
layout(binding = 0, rgba16f) uniform writeonly restrict image2D ambient_occlusion;
layout(binding = 1, r32ui) uniform writeonly restrict uimage2D depth_differences;

uniform uint u_frame;
uniform mat4 u_inverse_projection_mat;
uniform mat4 u_projection_mat;


// Approximates single-bounce ambient occlusion to multi-bounce ambient occlusion
// https://blog.selfshadow.com/publications/s2016-shading-course/activision/s2016_pbs_activision_occlusion.pdf#page=78
vec3 gtao_multibounce(float visibility, vec3 base_color) {
    vec3 a = 2.0404 * base_color - 0.3324;
    vec3 b = -4.7951 * base_color + 0.6417;
    vec3 c = 2.7552 * base_color + 0.6903;
    vec3 x = vec3(visibility);
    return max(x, ((x * a + b) * x + c) * x);
}

// float fast_sqrt(float x) {
//     return intBitsToFloat(0x1fbd1df5 + (floatBitsToInt(x) >> 1));
// }

// float fast_acos(float in_x) {
//     float x = abs(in_x);
//     float res = -0.156583 * x + 1.57079632679;
//     res *= fast_sqrt(1.0 - x);
//     return mix(PI - res, res, in_x >= 0.0);
// }

vec2 load_noise(ivec2 tex_coords) {
    // TODO:
    uint index = texelFetch(hilbert_index_lut, tex_coords % 64, 0).r;

#ifdef TEMPORAL_JITTER
    index += 288u * (u_frame % 64u);
#endif

	// R2 sequence - http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences
    return fract(0.5 + float(index) * vec2(0.75487766624669276005, 0.5698402909980532659114));
}

vec2 sign_not_zero(vec2 v) {
    return fma(step(vec2(0.0), v), vec2(2.0), vec2(-1.0));
}

// Unpacking from octahedron normals
// https://discourse.panda3d.org/t/glsl-octahedral-normal-packing/15233
vec3 unpack_normal(vec2 n) {
  vec3 v = vec3(n.xy, 1.0 - abs(n.x) - abs(n.y));
  if (v.z < 0) v.xy = (1.0 - abs(v.yx)) * sign_not_zero(v.xy);
  return normalize(v);
}

vec3 load_normal_view_space(vec2 uv) {
    vec2 packed_normal = textureLod(in_view_normals, uv, 0).xy;
	return unpack_normal(packed_normal);
}

vec3 reconstruct_view_space_position(float depth, vec2 uv) {
    vec2 clip_xy = uv * 2.0 - 1.0;
    vec4 t = u_inverse_projection_mat * vec4(clip_xy, depth, 1.0);
    t.xyz *= vec3(1, -1, -1);
    return t.xyz / t.w;
}

vec3 load_and_reconstruct_view_space_position(vec2 uv, float sample_mip_level) {
    float depth = textureLod(in_depth_mips, uv, sample_mip_level).r;
    return reconstruct_view_space_position(depth, uv);
}

float DirectionSpatialNoise(int x, int y)
{
    return (1.0/16.0) * ((((x + y) & 0x3) << 2) + (x & 0x3));
}

float OffsetSpatialNoise(int x, int y)
{
    return (1.0/4.0) * ((y - x) & 0x3);
}

float GTAOContribution(float angle, float angleN, float cosN, float sinN)
{
    return 0.25 * (-cos(2.0 * angle - angleN) + cosN + 2.0 * angle * sinN);
}

#define SLICE_COUNT 3
#define SAMPLES_PER_SLICE_SIDE 7

void main() {
    float kNumSlices = float(SLICE_COUNT);
    float kNumSamples = float(SAMPLES_PER_SLICE_SIDE);

	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 coord = vec2(pixelCoord) + vec2(0.5);
    vec2 imgSize = vec2(imageSize(ambient_occlusion).xy);
    coord /= imgSize;
    float aspect = u_projection_mat[1][1] / u_projection_mat[0][0]; // = imgSize.x / imgSize.y

    float depth = texelFetch(in_depth_mips, pixelCoord, 0).r;
	vec3 pos = reconstruct_view_space_position(depth, coord);
    vec3 V = normalize(-pos);
    vec3 N = load_normal_view_space(coord);
    N *= vec3(1, -1, -1);

    const float sampleStep = 1.0 / kNumSamples;

    float invZ = 1.0 / pos.z;
	float viewToScreenZ = 0.5 * u_projection_mat[1][1];
    float maxRadius = invZ * viewToScreenZ;
    maxRadius = clamp(maxRadius, 0.01, 0.25);

    float angleOffset = DirectionSpatialNoise(pixelCoord.x, pixelCoord.y) * PI;
    float sampleOffset = OffsetSpatialNoise(pixelCoord.x, pixelCoord.y);

    float visibility = 0.0;
    for (int sliceIndex = 0; sliceIndex < kNumSlices; ++sliceIndex)
    {
        float sliceAngle = sliceIndex * PI / kNumSlices;
        sliceAngle += angleOffset;

        vec3 sliceDir = vec3(cos(sliceAngle), sin(sliceAngle), 0.0);

        float maxCosL = -1.0;
        float maxCosR = -1.0;

        // Find max horizon angles in each direction
        float s = sampleOffset * sampleStep + sampleStep;
        for (int sampleIndex = 0; sampleIndex < kNumSamples; ++sampleIndex)
        {
            vec2 coordOffset = s * maxRadius * sliceDir.xy * vec2(1.0 / aspect, -1.0);

            vec2 coordR = coord + coordOffset;
            vec2 coordL = coord - coordOffset;

            vec3 samplePosR = load_and_reconstruct_view_space_position(coordR, 0);
            vec3 samplePosL = load_and_reconstruct_view_space_position(coordL, 0);

            vec3 horizonR = samplePosR - pos;
            vec3 horizonL = samplePosL - pos;

            float lengthR = length(horizonR);
            float lengthL = length(horizonL);

            float cosR = dot(horizonR/lengthR, V);
            float cosL = dot(horizonL/lengthL, V);

            // Lerp cosine of angle toward -1 with distance to give less weight to far occlusion
            cosR = mix(cosR, -1.0, max(lengthR - 0.5, 0.0));
            cosL = mix(cosL, -1.0, max(lengthL - 0.5, 0.0));

            maxCosR = max(maxCosR, cosR);
            maxCosL = max(maxCosL, cosL);

            s += sampleStep;
        }

        // Project normal N onto the slice plane
        vec3 sliceN = cross(sliceDir, V);
        vec3 projN = N - dot(sliceN, N) * sliceN;
        float projNLength = length(projN);

        vec3 sliceOrtho = sliceDir - dot(sliceDir, V) * V;
        float signN = sign(dot(projN, sliceOrtho));

        float cosN = clamp(dot(projN, V) / projNLength, 0.0, 1.0);
        float angleN = signN * acos(cosN);

        float angleR = acos(maxCosR);
        float angleL = -acos(maxCosL);

        // Clamp horizon angles to hemisphere around normal N
        angleR = angleN + min(angleR - angleN, 0.5 * PI);
        angleL = angleN + max(angleL - angleN, -0.5 * PI);

        float sinN = sin(angleN);
        float a = GTAOContribution(angleL, angleN, cosN, sinN) +
            GTAOContribution(angleR, angleN, cosN, sinN);

        visibility += projNLength * a;
    }
    visibility = visibility / kNumSlices;

    imageStore(ambient_occlusion, pixelCoord, vec4(visibility, 0.0, 0.0, 0.0));
}
